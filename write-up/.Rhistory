data = d
formula = list(structural = fs, instruments = fi)
data1 = model.frame(formula$structural, data)
data2 = model.frame(formula$instruments, data)



y = model.response(data1, type = "numeric")
    
Z = model.matrix(formula$structural, data = data1)
X = model.matrix(formula$instrument, data = data2)
    
l = ncol(X)
k = ncol(Z)
    
if (k >l ) stop( "# of regressors must <= # of instruments" )
    
    
    

    
J = n * t(G2Bar) %*% W2 %*% G2Bar
cat("\n J-stat = ", J, 
    ". DF = ", l-k, 
    ". p-value = ", 1-pchisq(J, df = l-k), ".\n")
'org_babel_R_eoe'
vcov <- vcov.fn(0, 0.5, 0.5)
X <- rmvn.chol(500, vcov)
print(apply(X, 2, function(i){var(i)}))
'org_babel_R_eoe'
library(gmm)

n = 10
k = 1
l = 2
d =  matrix(rnorm( (1+k+l)*n ), ncol = 1 + k + l)
colnames(d) = c("y", "x1", "z1", "z2", "z3", "z4", "z5")

d = d + 3

d[, 2:(1+k)]         = 2 + rowSums( d[, (1+k+1):(1+k+l)] )  + rnorm(n, 0, 0.2)
d[, 1] = 2 +  d[, (1 + 1):(1+k  )]   + rnorm(n, 0, 0.2)

fs = d$y ~ d$x1 
fi =     ~ d$z1 + d$z2 + d$z3 + d$z4 + d$z5


source("gmm_linear.R")
gmm.linear(list(structural = fs, instruments = fi), data = d)


n <- 10000
x <- rnorm(n)
z1 <- 3 + 0.50*x + rnorm(n, 0, 0.1)
z2 <- 1 + 0.25*x + rnorm(n, 0, 0.1)
y <- 2 + 3*x + 4*z1 + 5*z2 + rnorm(n)

X <- cbind(1, x)
Z <- cbind(1, z1, z2)
W = function(G) solve( (1/n) * (t(G)%*%G) )
A = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% X )
B = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% y )
betaHat = function(WW) {
  AA = A(WW)
  BB = B(WW)
  b = solve(AA, BB)
  return(b)
}
    
eHat = function(betaHat) y - X %*% betaHat # the residual

W1 = W(Z)
betaHat1 = betaHat(W1)
    
e = eHat(betaHat1)
G2 = Z * matrix(rep(e, 3), ncol = 3)
G2Bar = colMeans(G2)
W2 = solve( (t(G2)%*%G2)/n   -  G2Bar %*% t(G2Bar)  )
betaHat2 = betaHat(W2)
    
Q = crossprod(Z, X)/n
V = solve( t(Q) %*%  W2 %*% Q )
s = sqrt(diag(V)/n)
    
summ = cbind(betaHat2, s, betaHat2/s, 2*(1-pnorm(abs(betaHat2/s))) )
colnames(summ) = c("coefficient", "s.d.", "Z", "p-value")
print(summ)

data = d
formula = list(structural = fs, instruments = fi)
data1 = model.frame(formula$structural, data)
data2 = model.frame(formula$instruments, data)



y = model.response(data1, type = "numeric")
    
Z = model.matrix(formula$structural, data = data1)
X = model.matrix(formula$instrument, data = data2)
    
l = ncol(X)
k = ncol(Z)
    
if (k >l ) stop( "# of regressors must <= # of instruments" )
    
    
    

    
J = n * t(G2Bar) %*% W2 %*% G2Bar
cat("\n J-stat = ", J, 
    ". DF = ", l-k, 
    ". p-value = ", 1-pchisq(J, df = l-k), ".\n")
'org_babel_R_eoe'
install.packages("MCMCpack")
library(MCMCpack)
 xpnd(c(1,2,3,4,4,5,6,7,8,9),4)
 xpnd(c(1,2,3,4,4,5,6,7,8,9))
 xpnd(c(1,2,3,4,4,5,6,7,8,9)
vcov
172/70
55*(172/70)
colnames
mat
vcov
colnames(vcov) <- c("x", "x", "x", "x")
vcov
vcov.fn(0.1, 0.5, 0.4, 0.4, 0.1)
vcov.fn(0.1, 0.5, 0.4, 0.4, 0.1)
vcov <- vcov.fn(0, 0.5, 0.5)
X <- rmvn.chol(500, vcov)
print(apply(X, 2, function(i){var(i)}))
'org_babel_R_eoe'
library(gmm)

n = 10
k = 1
l = 2
d =  matrix(rnorm( (1+k+l)*n ), ncol = 1 + k + l)
colnames(d) = c("y", "x1", "z1", "z2", "z3", "z4", "z5")

d = d + 3

d[, 2:(1+k)]         = 2 + rowSums( d[, (1+k+1):(1+k+l)] )  + rnorm(n, 0, 0.2)
d[, 1] = 2 +  d[, (1 + 1):(1+k  )]   + rnorm(n, 0, 0.2)

fs = d$y ~ d$x1 
fi =     ~ d$z1 + d$z2 + d$z3 + d$z4 + d$z5


source("gmm_linear.R")
gmm.linear(list(structural = fs, instruments = fi), data = d)


n <- 10000
x <- rnorm(n)
z1 <- 3 + 0.50*x + rnorm(n, 0, 0.1)
z2 <- 1 + 0.25*x + rnorm(n, 0, 0.1)
y <- 2 + 3*x + 4*z1 + 5*z2 + rnorm(n)

X <- cbind(1, x)
Z <- cbind(1, z1, z2)
W = function(G) solve( (1/n) * (t(G)%*%G) )
A = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% X )
B = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% y )
betaHat = function(WW) {
  AA = A(WW)
  BB = B(WW)
  b = solve(AA, BB)
  return(b)
}
    
eHat = function(betaHat) y - X %*% betaHat # the residual

W1 = W(Z)
betaHat1 = betaHat(W1)
    
e = eHat(betaHat1)
G2 = Z * matrix(rep(e, 3), ncol = 3)
G2Bar = colMeans(G2)
W2 = solve( (t(G2)%*%G2)/n   -  G2Bar %*% t(G2Bar)  )
betaHat2 = betaHat(W2)
    
Q = crossprod(Z, X)/n
V = solve( t(Q) %*%  W2 %*% Q )
s = sqrt(diag(V)/n)
    
summ = cbind(betaHat2, s, betaHat2/s, 2*(1-pnorm(abs(betaHat2/s))) )
colnames(summ) = c("coefficient", "s.d.", "Z", "p-value")
print(summ)

data = d
formula = list(structural = fs, instruments = fi)
data1 = model.frame(formula$structural, data)
data2 = model.frame(formula$instruments, data)



y = model.response(data1, type = "numeric")
    
Z = model.matrix(formula$structural, data = data1)
X = model.matrix(formula$instrument, data = data2)
    
l = ncol(X)
k = ncol(Z)
    
if (k >l ) stop( "# of regressors must <= # of instruments" )
    
    
    

    
J = n * t(G2Bar) %*% W2 %*% G2Bar
cat("\n J-stat = ", J, 
    ". DF = ", l-k, 
    ". p-value = ", 1-pchisq(J, df = l-k), ".\n")
'org_babel_R_eoe'
vcov <- vcov.fn(0, 0.5, 0.5)
X <- rmvn.chol(500, vcov)
print(apply(X, 2, function(i){var(i)}))
'org_babel_R_eoe'
library(gmm)

n = 10
k = 1
l = 2
d =  matrix(rnorm( (1+k+l)*n ), ncol = 1 + k + l)
colnames(d) = c("y", "x1", "z1", "z2", "z3", "z4", "z5")

d = d + 3

d[, 2:(1+k)]         = 2 + rowSums( d[, (1+k+1):(1+k+l)] )  + rnorm(n, 0, 0.2)
d[, 1] = 2 +  d[, (1 + 1):(1+k  )]   + rnorm(n, 0, 0.2)

fs = d$y ~ d$x1 
fi =     ~ d$z1 + d$z2 + d$z3 + d$z4 + d$z5


source("gmm_linear.R")
gmm.linear(list(structural = fs, instruments = fi), data = d)


n <- 10000
x <- rnorm(n)
z1 <- 3 + 0.50*x + rnorm(n, 0, 0.1)
z2 <- 1 + 0.25*x + rnorm(n, 0, 0.1)
y <- 2 + 3*x + 4*z1 + 5*z2 + rnorm(n)

X <- cbind(1, x)
Z <- cbind(1, z1, z2)
W = function(G) solve( (1/n) * (t(G)%*%G) )
A = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% X )
B = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% y )
betaHat = function(WW) {
  AA = A(WW)
  BB = B(WW)
  b = solve(AA, BB)
  return(b)
}
    
eHat = function(betaHat) y - X %*% betaHat # the residual

W1 = W(Z)
betaHat1 = betaHat(W1)
    
e = eHat(betaHat1)
G2 = Z * matrix(rep(e, 3), ncol = 3)
G2Bar = colMeans(G2)
W2 = solve( (t(G2)%*%G2)/n   -  G2Bar %*% t(G2Bar)  )
betaHat2 = betaHat(W2)
    
Q = crossprod(Z, X)/n
V = solve( t(Q) %*%  W2 %*% Q )
s = sqrt(diag(V)/n)
    
summ = cbind(betaHat2, s, betaHat2/s, 2*(1-pnorm(abs(betaHat2/s))) )
colnames(summ) = c("coefficient", "s.d.", "Z", "p-value")
print(summ)

data = d
formula = list(structural = fs, instruments = fi)
data1 = model.frame(formula$structural, data)
data2 = model.frame(formula$instruments, data)



y = model.response(data1, type = "numeric")
    
Z = model.matrix(formula$structural, data = data1)
X = model.matrix(formula$instrument, data = data2)
    
l = ncol(X)
k = ncol(Z)
    
if (k >l ) stop( "# of regressors must <= # of instruments" )
    
    
    

    
J = n * t(G2Bar) %*% W2 %*% G2Bar
cat("\n J-stat = ", J, 
    ". DF = ", l-k, 
    ". p-value = ", 1-pchisq(J, df = l-k), ".\n")
'org_babel_R_eoe'
vcov <- vcov.fn(0, 0.5, 0.5)
X <- rmvn.chol(500, vcov)
print(apply(X, 2, function(i){var(i)}))
'org_babel_R_eoe'
library(gmm)

n = 10
k = 1
l = 2
d =  matrix(rnorm( (1+k+l)*n ), ncol = 1 + k + l)
colnames(d) = c("y", "x1", "z1", "z2", "z3", "z4", "z5")

d = d + 3

d[, 2:(1+k)]         = 2 + rowSums( d[, (1+k+1):(1+k+l)] )  + rnorm(n, 0, 0.2)
d[, 1] = 2 +  d[, (1 + 1):(1+k  )]   + rnorm(n, 0, 0.2)

fs = d$y ~ d$x1 
fi =     ~ d$z1 + d$z2 + d$z3 + d$z4 + d$z5


source("gmm_linear.R")
gmm.linear(list(structural = fs, instruments = fi), data = d)


n <- 10000
x <- rnorm(n)
z1 <- 3 + 0.50*x + rnorm(n, 0, 0.1)
z2 <- 1 + 0.25*x + rnorm(n, 0, 0.1)
y <- 2 + 3*x + 4*z1 + 5*z2 + rnorm(n)

X <- cbind(1, x)
Z <- cbind(1, z1, z2)
W = function(G) solve( (1/n) * (t(G)%*%G) )
A = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% X )
B = function(WW) ((1/n) * t(X) %*% Z) %*% WW %*% ((1/n) * t(Z) %*% y )
betaHat = function(WW) {
  AA = A(WW)
  BB = B(WW)
  b = solve(AA, BB)
  return(b)
}
    
eHat = function(betaHat) y - X %*% betaHat # the residual

W1 = W(Z)
betaHat1 = betaHat(W1)
    
e = eHat(betaHat1)
G2 = Z * matrix(rep(e, 3), ncol = 3)
G2Bar = colMeans(G2)
W2 = solve( (t(G2)%*%G2)/n   -  G2Bar %*% t(G2Bar)  )
betaHat2 = betaHat(W2)
    
Q = crossprod(Z, X)/n
V = solve( t(Q) %*%  W2 %*% Q )
s = sqrt(diag(V)/n)
    
summ = cbind(betaHat2, s, betaHat2/s, 2*(1-pnorm(abs(betaHat2/s))) )
colnames(summ) = c("coefficient", "s.d.", "Z", "p-value")
print(summ)

data = d
formula = list(structural = fs, instruments = fi)
data1 = model.frame(formula$structural, data)
data2 = model.frame(formula$instruments, data)



y = model.response(data1, type = "numeric")
    
Z = model.matrix(formula$structural, data = data1)
X = model.matrix(formula$instrument, data = data2)
    
l = ncol(X)
k = ncol(Z)
    
if (k >l ) stop( "# of regressors must <= # of instruments" )
    
    
    

    
J = n * t(G2Bar) %*% W2 %*% G2Bar
cat("\n J-stat = ", J, 
    ". DF = ", l-k, 
    ". p-value = ", 1-pchisq(J, df = l-k), ".\n")
'org_babel_R_eoe'
dim(data)
dim(beta)
dim(beta)
y
eta
beta
variance(eta)
var(eta)
var(y)
Z %*% t(Z)
solve(t(Z) %*% X)
solve(t(X) %*% Z %*% t(Z) %*% X)
solve(t(X) %*% Z %*% t(Z) %*% X)
t(X) %*% Z %*% t(Z) %*% X
solve(t(X) %*% Z %*% t(Z) %*% X)
solve(t(X) %*% Z %*% t(Z) %*% X)
solve(t(Z) %*% Z)
W <- solve(t(Z) %*% Z)
head(X)
W <- solve(t(Z) %*% Z)
W
A <- t(X) %*% Z
A
A %*% W
A %*% W %*% t(A)
solve(A %*% W %*% t(A))
vcov
solve(vcov)
head(data)
W <- solve(t(Z) %*% Z)
A <- t(X) %*% Z
solve(A %*% W %*% t(A))
betaHat2
betaHat2
betaHat2
A <- t(X) %*% Z
solve(A %*% t(A))
AA <- solve(A %*% t(A))
BB <- A %*% t(Z) %*% y
AA %*% BB
e <- y - t(X) %*% AA %*% BB
e <- y - t(X) %*% (AA %*% BB)
beta.hat <- AA %*% BB
dim(X)
e <- y - t(X) %*% beta.hat
dim(beta.hat)
e <- y - X %*% beta.hat
e
g <- Z %*% e
g <- t(Z) %*% e
g
g <- Z * e
dim(Z)
betaHat2
betaHat2
A(W1) %*% B(W1)
solve(A(W1)) %*% B(W1)
solve(A(W1)) %*% B(W1)
hist(res)
hist(res, breaks=100)
rmvn.chol(50, vcov)
vcov
hist(res, breaks=100)
solve(vcov)
res
ls
library(spdep)
library(spdep)
?mat2list2
?mat2listw
example(columbus)
coords <- coordinates(columbus)
coords
col005 <- dnearneigh(coords, 0, 0.5, attr(col.gal.nb, "region.id"))
col005
summary(col005)
     col005.w.mat <- nb2mat(col005, zero.policy=TRUE)
     col005.w.b <- mat2listw(col005.w.mat)
     summary(col005.w.b$neighbours)
col005.w.mat
dim(col005.w.mat)
dim(col005.w.b)
summary(col005.w.b)
object(col005.w.b)
objects(col005.w.b)
col005.w.b$neighbours
col005.w.b$weights
length(col005.w.b$weights)
for (i in col005.w.b$weights):
for i in 1:length(col005.w.b$weights):
for (i in 1:length(col005.w.b$weights)):
?for
for (i in col005.w.b$weights)
  print(i)
?write.csv
col005
objects(col005)
objects(col005.w.mat)
     example(columbus)
     coords <- coordinates(columbus)
     col005 <- dnearneigh(coords, 0, 0.5, attr(col.gal.nb, "region.id"))
     summary(col005)
     col005.w.mat <- nb2mat(col005, zero.policy=TRUE)
     col005.w.b <- mat2listw(col005.w.mat)
     summary(col005.w.b$neighbours)
     diffnb(col005, col005.w.b$neighbours)
     col005.w.mat.3T <- kronecker(diag(3), col005.w.mat)
     col005.w.b.3T <- mat2listw(col005.w.mat.3T, style="W")
     summary(col005.w.b.3T$neighbours)
objects(col005.w.mat)
summary(col005)
summary(col005.w.mat)
col005.w.mat[1]
col005.w.mat[2]
col005.w.mat[2,]
col005.w.mat[1,]
col005.w.mat[2,]
?which
which(col005.w.mat[2,] > 0)
which(col005.w.mat[2,] > 0, arr.ind=TRUE)
